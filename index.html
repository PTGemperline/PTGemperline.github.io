<!DOCTYPE html>
<html>
<body>
<h1>Welcome To Patrick's Blog</h1>
  <h2>Chapter 8 Pragmatic Projects</h2>
    <p> The final chapter just reitterated what the book had already said before. Teams need to be strict and careful. Test all the time
      and more frequently than that. Teams should automate everything they possibly can. Automate all the build stuff and all the tests of
      of course. Most important of all is to meet the expectations. Make sure to lower unrealistic expectations and to possibly raise low 
      expectations. Most important thing is succeding.
      <br>
  <h2>Chapter 7 Before the Project</h2>
    <p> Requirements are not expectations. Expectations are the things you are told your program needs to do. The requirements are the
      things you have to do in order to make your program meet the expectations. This means that although the expectations might sound easy
      and straight forward, but in reality the work needed to complete them might not. Make sure that the problems you are facing are the 
      right ones. You very well might be seeing an impossible problem where two highly managable problems should be.
      <br>
  <h2>Chapter 6 While You Are Coding</h2>
    <p> This chapter made it very clear that undestandig your code is very important. The idea is that your code you wrote now will be 
      used in the future. If it is poorly written, cumbersom or buggy then it will cause more problems going forward. It also said that 
      analyzing the rate at which your code runs is important. It also says that you should estimate your code in theory and then test
      your theory to see if its correct.
      <br>
  <h2>Chapter 5 Bend or Break</h2>
    <p> Make code really really flexible. Basically just make your code so that it won't have to be changed anytime soon. This is done by 
      making classes not overly complex. Make classes not rely on too many others. Make options as plentiful as possible so that
      customization is easy and can be done at anytime. Make steps unordered if possible so that things can be done anacranisticly.</p>
      <br>
  <h2>Chapter 4 Pragmatic Paranoia </h2>
    <p> So the basic idea is that code is not perfect but it can be made to run well. The chapter focused on the things you can do to make 
      your code more optimized. Firstly is the idea that you should focus on making sure that all processes are destroyed by their
      creaters. You should also avoid exceptions when possible. Make checks for edge cases and errors and do not get worried if you have
      alot of them. Its better to work safely than work just a bit quicker.</p>
      <br>
  <h2>Mythical Man-Month</h2>
    <p> This section of this book seems to basically cover the fact that people are bad at estimation. Some of the key notes are that people
      confuse man-hours with actual hours. This basically means that the relationship between the nubmer of people you have working on it is
      not direclty proportional to the amount of hours it would take if 1 person was on it. According to the book its actually inversly 
      proportional for a job where communicationis uses. If the job is more complex with lots of interrelated parts then it goes about 
      parabolically with a negative corolation early on but a posative corolation later. I wonder where they got the trends for these plots 
      but otherwise I would agree with what they said. Seems pretty intuative to me but then again I just always use the strategy of 
      wildly over estimating and then surprising people when it gets done early.</p>
      <br>
  <h2>12 Factor App</h2>
    <p> Several things from the "Twelve-Factor App" were intersting and I'll just touch on a few of them. First of all is the requirement 
      that an app be held entirely in one place. According to the reading "If there are multiple codebases, it’s not an app – it’s a 
      distributed system. Each component in a distributed system is an app, and each can individually comply with twelve-factor." This is 
      very interesting to me because it seems that if we keep the differnt parts of our project in different places then its actually 3 apps
      instead of one.The second thing that I thought was nifty was the way in which the processes are handled. The model requires that the 
      processes be handled all as "individual citizens" meaning they are all created seperately. Apparently this allows the program to scale
      better than other wise. "In the twelve-factor app, processes are a first class citizen."</p>
      <br>
  <h2>Chapter 3</h2>
    <p>I think this chapter is kind of obvious. The point seems to be that without the proper tools a programer cannot do their job. But
      we all know this. When I read this chapter I thought back to the times when I didn't use version control or a debugger. I think they
      were talking about the progarms we use, but I would disagree that they are needed. I belive all you need is a text editor and the words
      import.</p>
      <br>
  <h2>Thoughts on chapter dos</h2>
    <p>I belive I'm starting to see where this book is going. It is not a step by step how to, its a book of suggestions. And here are
      my thoughts on the some of the ones from chapter 2.</p>
    <p>They drilled hard into the idea that things should not be repeated. The idea is pretty clear, if you wrote it once it's more work to
      write it again. But more than that, if you wrote it once then it means you have to sections that do the same thing and that's gonna 
      cause complications downt he line. From recent experience I can verify that this is not easy. At least not when you are working with 
      a group of people, but in that case it is probably even more important.</p>
    <p>This seems to me to run right into their idea of orthogonality. Now I personally think of orthogonality in mathimatical principles 
      where the inner product of to orthogonal things is zero. But I belive its a novel analogy to softare engineering. The inner product
      is often refered to as a mapping of one thing onto another. So if code is orthogonal, then when you map it to other sections of code,
      it has not like components and thus is 0. So basically make code simple and self reliant as much as possible and your good.</p>
      <br>
  <h2> What I found interesting in chapter 1</h2>
  <p> Not what I was expecting at all. When I envisioned a book about coding I expected lists of commands and shortucuts and things you 
    should do to make code easily integrable with other code. Not what it was. Instead the whole first chapter was very general and just 
    brushed over what it means to be a good programer. The section about your knowledge portfolio was interesting and made sense, but I'm
    still waiting for when the book is going to really focus on code. Although maybe I just mistunderstood what the purpose of it is.
    <br>
  <h2>What Software Engineering means to me</h2>
    <p> I really don't get how software engineering is any different to coding. As far as i can tell its the same thing but with alot of
      people and fancy programs to make it faster. According to a friend "its getting used to working with alot of people and combining
      your efforts into a large project. You have to learn how to use development environements and git to become a better coder." I'm not
      really sure but I'm looking forward to learning more about it.</p>
  <br>
</body>
</html>
