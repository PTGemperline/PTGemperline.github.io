<!DOCTYPE html>
<html>
<body>
<h1>Welcome To Patrick's Blog</h1>
  <h2>12 Factor App</h2>
    <p> Several things from the "Twelve-Factor App" were intersting and I'll just touch on a few of them. First of all is the requirement 
      that an app be held entirely in one place. According to the reading "If there are multiple codebases, it’s not an app – it’s a 
      distributed system. Each component in a distributed system is an app, and each can individually comply with twelve-factor." This is 
      very interesting to me because it seems that if we keep the differnt parts of our project in different places then its actually 3 apps
      instead of one.The second thing that I thought was nifty was the way in which the processes are handled. The model requires that the 
      processes be handled all as "individual citizens" meaning they are all created seperately. Apparently this allows the program to scale
      better than other wise. "In the twelve-factor app, processes are a first class citizen."
  <h2>Chapter 3</h2>
    <p>I think this chapter is kind of obvious. The point seems to be that without the proper tools a programer cannot do their job. But
      we all know this. When I read this chapter I thought back to the times when I didn't use version control or a debugger. I think they
    were talking about the progarms we use, but I would disagree that they are needed. I belive all you need is a text editor and the words
    import.</p>
      <br>
  <h2>Thoughts on chapter dos</h2>
    <p>I belive I'm starting to see where this book is going. It is not a step by step how to, its a book of suggestions. And here are
      my thoughts on the some of the ones from chapter 2.</p>
    <p>They drilled hard into the idea that things should not be repeated. The idea is pretty clear, if you wrote it once it's more work to
      write it again. But more than that, if you wrote it once then it means you have to sections that do the same thing and that's gonna 
      cause complications downt he line. From recent experience I can verify that this is not easy. At least not when you are working with 
      a group of people, but in that case it is probably even more important.</p>
    <p>This seems to me to run right into their idea of orthogonality. Now I personally think of orthogonality in mathimatical principles 
      where the inner product of to orthogonal things is zero. But I belive its a novel analogy to softare engineering. The inner product
      is often refered to as a mapping of one thing onto another. So if code is orthogonal, then when you map it to other sections of code,
      it has not like components and thus is 0. So basically make code simple and self reliant as much as possible and your good.</p>
      <br>
  <h2> What I found interesting in chapter 1</h2>
  <p> Not what I was expecting at all. When I envisioned a book about coding I expected lists of commands and shortucuts and things you 
    should do to make code easily integrable with other code. Not what it was. Instead the whole first chapter was very general and just 
    brushed over what it means to be a good programer. The section about your knowledge portfolio was interesting and made sense, but I'm
    still waiting for when the book is going to really focus on code. Although maybe I just mistunderstood what the purpose of it is.
    <br>
  <h2>What Software Engineering means to me</h2>
    <p> I really don't get how software engineering is any different to coding. As far as i can tell its the same thing but with alot of
      people and fancy programs to make it faster. According to a friend "its getting used to working with alot of people and combining
      your efforts into a large project. You have to learn how to use development environements and git to become a better coder." I'm not
      really sure but I'm looking forward to learning more about it.</p>
  <br>
</body>
</html>
